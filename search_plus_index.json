{"./":{"url":"./","title":"简介","keywords":"","body":" 关于Web前端知识的一些整理 1.HTML基础 常用标签整理 常用属性和样式 2.CSS布局 圣杯布局和双飞翼布局 Flex弹性布局 简介 容器属性 项目属性 Grid网格布局 简介 容器属性 项目属性 3.其他 静态资源压缩 gh-pages 部署 webpack 的简单使用 GitBook 的简单使用 专注之后，始能忘忧...®Python, Ruby, PHP & web前端Copyright © Mr. Yao all right reserved, powered by skyFimodified at 2020-04-15 23:19:43 "},"HTML基础/":{"url":"HTML基础/","title":"1.HTML基础","keywords":"","body":"HTML基础 常用标签整理 常用属性和样式 专注之后，始能忘忧...®Python, Ruby, PHP & web前端Copyright © Mr. Yao all right reserved, powered by skyFimodified at 2020-04-13 23:11:56 "},"HTML基础/1_HTML标签常用整理.html":{"url":"HTML基础/1_HTML标签常用整理.html","title":"1.1.HTML标签常用整理","keywords":"","body":" 如题，本文主要描述博主对之前前端学习中HTML5标签的一些整理。 一、基本分类 HTML4中，元素被分成两大类: inline(内联元素)与block(块级元素)。 1. 块级元素 每个块级元素独占一行， 可以直接控制宽度、高度以及盒子模型的相关css属性， 默认情况下，其宽度为父级元素内容的宽度， 默认情况下，其高度为本身内容的高度。 常用的块级元素有： 标签 描述 常用块级元素，多用于布局 ... 一到六级标题 、、 有序列表、无序列表、列表项 、、 自定义列表、定义术语（列表项）、定义项目描述 表格 段落，也称行内元素 定义文档作者或拥有者的联系信息 HTML 表单 水平分隔线 导航 侧边栏 菜单列表 文章 对话窗口 、 页眉、页脚 ... ... 2. 内联元素 本身属性为display:inline的元素，即和相邻的内联元素在同一行， 宽高、内外边距（垂直属性）不可改变， 宽高是由内容本身的大小决定的（文字、图片等） 常用的内联元素有： 标签 描述 、 锚点、加粗 常用的内联容器，定义文本内区块 换行 定义斜体字 定义强调文本 加粗强调 定义 input 元素的标注 定义引用 定义计算机代码文本，可以和连用 图片 输入框 下拉列表 、 定义下标文本、上标文本 文本域 ... ... HTML5中，元素主要分为7类：Metadata（元数据元素）、Flow（流式元素）、Sectioning（章节元素）、Heading（标题元素）、Phrasing（段落元素）、Embedded（嵌入元素）、Interactive（交互元素）。 具体描述，可见：HTML5元素分类与内容模型。 二、HTML5新增特性 相对于HTML4，新增了语义化更好的标签元素和API。 1. 这里列举其中几个常用的标签： 标签 描述 文章 侧边栏 导航组 定义视频 定义音频 定义图形，比如图表和其他图像，该标签是基于js的绘图api 定义使用 SVG 的图像绘制， XML 格式定义图形 状态标签（任务过程：安装、加载） 菜单列表 定义日期/时间 ruby注释 定义对话框或窗口 定义用户可查看或隐藏的额外细节 定义输入控件的预定义选项 定义表单里一个生产的键值，加密信息传送 定义计算结果 ... ... 2. 新增的API有： 上面提的 和 ，一个是基于js的绘图api，一个是使用 XML 格式定义矢量图形api，各有千秋。 Geolocation（地理定位）：用于获得用户的地理位置的api，getCurrentPosition()方法用于检测是否支持定位，showPosition() 函数获得并显示经度和纬度。 Drag/Drop（拖放）： 把 draggable 属性设置为 'true'，表示设置元素拖放，具体操作参考api中的方法。 web存储：localStorage、sessionStorage 。 应用程序缓存：通过给 标签中添加 manifest属性，启用应用程序缓存，manifest 文件的建议文件扩展名为\".appcache\"。 WebSockets：要连接远程主机，只需新建一个WebSocket实例，提供希望连接的对端URL。 更多，可见：W3school - HTML5 新元素 三、部分标签使用 1. 列表 购物车 1.苹果 2.香蕉 3.蓝莓 饮料 1.牛奶 2.橙汁 3.奶茶 php 全球通用服务器端编程语言 mysql 全球最广泛的开源关系型数据库系统 Laravel 全球最广泛的开源PHP开发框架 显示： 2. 表格 表格 购物车 编号 名称 单价 数量 金额 付款人 1 电脑 10000 1 10000 Alfred 2 手机 2000 2 4000 3 鼠标 300 3 900 合计 6 14900 显示： 3. 表单控件 表单和表单控件 用户注册 基本信息 账号： 密码： 邮箱： 年龄： 兴趣爱好 课程： 请选择 HTML5 CSS3 JavaScript PHP mysql Laravel 爱好： 玩游戏 编程 影视 性别： 男生 女生 保密 按钮操作 注册 1.placeholder：设置提示信息或默认值； 2.autofocus：自动获取输入焦点； e.g. 3.required：设置字段为必填项； e.g. 4.pattern：正则表达式验证，更加精准的控制用户的输入； e.g. 5.list：list属性值必须与input的id值一致，实现dataliist列表与控件绑定； 6.width和height：（宽高）只要设置其中一个即可，另一个等比缩放； e.g. 7.min、max和step：区间和步长设置； e.g. 8.novalidate：提交时放弃数据验证（交给服务器验证）； e.g. 1.number：仅限数值型数据； e.g. 2.date：仅限日期类型数据； e.g. 3.time：仅限时间型数据，只允许设置小时区间，分钟供参考； e.g. 以上都是输入时验证； 4.email：仅限于电邮地址类型； e.g. 5.search：有内容时，会显示一个取消图标； 6.url：仅限以http:// 或 https:// 开头的url地址； 以上类型，提交时验证； 7.color：通过系统调色板来获取颜色，返回16进制颜色值； e.g. 获取颜色值 document.getElementById(\"btn\").onclick=function(){ document.getElementById(\"color-value\").value = document.getElementById(\"color\").value; } 搜索： html css3 javascript vue bootstrap php python ruby 音视频标签 街舞 显示： 结束！ 原文地址： CSDN博客 - Web前端（一） - HTML标签常用整理！ 专注之后，始能忘忧...®Python, Ruby, PHP & web前端Copyright © Mr. Yao all right reserved, powered by skyFimodified at 2020-04-13 23:17:48 "},"HTML基础/2_HTML标签常用属性和CSS样式.html":{"url":"HTML基础/2_HTML标签常用属性和CSS样式.html","title":"1.2.HTML标签常用属性和CSS样式","keywords":"","body":" 本文主要记录一下HTML标签的常用属性和CSS样式。 1.一些特殊标签 标签 描述 粗体字 粗体字，强调 斜体字 斜体字，强调 斜体定义 底线 底线，插入文字 横线 、 删除线 键盘文字 打字体，H5不支持 固定宽度的字体，在文件中空白，换行 预格式化 源代码 ... ... 2.常用属性及样式 2.1. 背景、颜色 background：背景 color：颜色，可用颜色名称、16进制、rgb元组表示 opacity：透明度，也可用rgba()的第四参数指定，filter可添加可视效果 2.2. 形状边界 width/height：宽/高，同时有最大/小值、比例等设置 border-radius：圆角 border-shadow：添加阴影 border-image：边界图片，不支持IE resize：调整尺寸，由用户调整，IE不兼容，e.g.：resize:both;... box-sizing：方框大小调整，以确切方式定义适应某区域具体内容 outline-offset：对轮廓进行偏移，并在超出边缘的位置绘制轮廓 2.3. 位置排布 top/right/bottom/left：上/右/下/左 position：位置布局，relative - 相对、absolute - 绝对 float：浮动 display：显示样式，如：none、block、inline、inherit、flex ... align/text-align/vertical-align：位置显示设置 margin/padding：外/内 边距 transform：元素空间位置变换 2.4. 文本效果 @font-face规则：可通过font-family指定字体类型，src指定字体url，font-weight指定字体粗细等等 text-shadow：文本阴影 box-shadow：盒子阴影 text-overflow：定义如何显示溢出内容 word-wrap：允许文本换行 word-break：单词拆分换行属性，指定换行规则 2.5. 2/3D转换 2D： translate()方法：根据左（X）轴和顶（Y）轴位置参数，从当前位置移动 rotate()方法：对于给定参数的元素，顺/逆时针旋转 scale()方法：对给定参数（x,y）的元素增加或减少大小 skew()方法：（x,y）对应两轴的倾斜角 ... 3D: matrix()方法：有六个参数，为合并方法，包含上述功能 rotateX()方法：围绕一个给定度数的X轴旋转元素 rotateY()方法：围绕一个给定度数的Y轴旋转元素 ... 专注之后，始能忘忧...®Python, Ruby, PHP & web前端Copyright © Mr. Yao all right reserved, powered by skyFimodified at 2020-04-13 23:18:11 "},"CSS布局/":{"url":"CSS布局/","title":"2.CSS布局","keywords":"","body":"关于CSS布局的一些整理 CSS布局 圣杯布局和双飞翼布局 Flex弹性布局 简介 容器属性 项目属性 Grid网格布局 简介 容器属性 项目属性 专注之后，始能忘忧...®Python, Ruby, PHP & web前端Copyright © Mr. Yao all right reserved, powered by skyFimodified at 2020-04-12 11:25:28 "},"CSS布局/圣杯+双飞翼布局/":{"url":"CSS布局/圣杯+双飞翼布局/","title":"2.1.圣杯+双飞翼布局","keywords":"","body":"圣杯布局和双飞翼布局 1.三栏布局 所谓的 '三栏布局'， 即：左右两栏固定宽度，中间部分自适应的布局方式。 2.相同点： 都是浮动布局，在实现三栏布局； 左右两边加上负的margin值，使之与中间并排； 中间盒子优先渲染，两边的盒子框子固定不变，即使页面宽度变小，也不影响浏览。 3.不同点： 圣杯布局：通过父容器的内边距（padding）来实现各列的间隙； 双飞翼布局：通过新建的div的外边距（margin）隔离各列。 专注之后，始能忘忧...®Python, Ruby, PHP & web前端Copyright © Mr. Yao all right reserved, powered by skyFimodified at 2020-04-12 21:52:07 "},"CSS布局/圣杯+双飞翼布局/1_圣杯布局.html":{"url":"CSS布局/圣杯+双飞翼布局/1_圣杯布局.html","title":"2.1.1.圣杯布局","keywords":"","body":"圣杯布局 1.实现方式 三者都设置向左浮动，脱离文档流，且设置 position: relative; 设置 main 宽度为100%； 设置 负边距，left 设置负左边距为自身宽度，right 设置负右边距为自身宽度； container 设置 padding: 0, rightWidth, 0, leftWidth;，给左右两个子面板留出空间，同时 设置overflow: hidden; 2.DOM分布 middle left right 参考：知乎、掘金 专注之后，始能忘忧...®Python, Ruby, PHP & web前端Copyright © Mr. Yao all right reserved, powered by skyFimodified at 2020-04-12 21:57:44 "},"CSS布局/圣杯+双飞翼布局/2_双飞翼布局.html":{"url":"CSS布局/圣杯+双飞翼布局/2_双飞翼布局.html","title":"2.1.2.双飞翼布局","keywords":"","body":"双飞翼布局 1.实现方式 三者都设置向左浮动，脱离文档流； 设置 main-wraper 宽度为100%； 设置 负边距，left 设置 margin-left: -100%，right 设置 margin-left: 为负的自身宽度； container 设置 margin: 0, rightWidth, 0, leftWidth;，给左右两个子面板留出空间，同时 设置overflow: hidden; 2.DOM排列 middle left right 参考：知乎、掘金 专注之后，始能忘忧...®Python, Ruby, PHP & web前端Copyright © Mr. Yao all right reserved, powered by skyFimodified at 2020-04-12 21:57:48 "},"CSS布局/Flex弹性布局/":{"url":"CSS布局/Flex弹性布局/","title":"2.2.Flex弹性布局","keywords":"","body":"Flex弹性布局 资源来源于网络 1.简介 2.基本概念 3.容器属性 4.项目属性 专注之后，始能忘忧...®Python, Ruby, PHP & web前端Copyright © Mr. Yao all right reserved, powered by skyFimodified at 2020-04-15 22:15:39 "},"CSS布局/Flex弹性布局/1_概论.html":{"url":"CSS布局/Flex弹性布局/1_概论.html","title":"2.2.1.概论","keywords":"","body":"Flex应用场景 资源来源于网络 网页布局（layout）是 CSS 的一个重点应用。 布局的传统解决方案，基于盒状模型，依赖 display 属性 + position属性 + float属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。 2009年, W3C提出一个新方案: Flex布局 可简更加的简单的实现,响应式的布局, 并且得到了几乎所有浏览器的支持, 所以请放心大胆的用吧 所以, Flex必将成为未来布局的首选方案, 下节课咱们就来详细介绍一下它的基本语法知识 专注之后，始能忘忧...®Python, Ruby, PHP & web前端Copyright © Mr. Yao all right reserved, powered by skyFimodified at 2020-04-15 22:18:29 "},"CSS布局/Flex弹性布局/2_Flex布局是什么.html":{"url":"CSS布局/Flex弹性布局/2_Flex布局是什么.html","title":"2.2.2.Flex布局是什么","keywords":"","body":"Flex 布局是什么? 资源来源于网络 Flex 简介 Flex 是 Flexible Box的缩写, 意思是\"弹性布局\", 用来为盒状模型提供最大的布局灵活性 任何一个容器都可以设置为Flex布局模式 /* 块元素可以设置为Flex容器 */ .container { display: flex; } /*内联元素也可以设置为Flex*/ span { display: inline-flex; } /* WebKit内核浏览器,如Safari, 需要加前缀*/ div { display: -webkit-flex; /*Safari*/ display: lfex; } 一旦设置为Flex容器, 则容器内子元素的float, clear, vertical-align属性全部失去意义, 没有效果了 由此可见, Flex布局的目标明确, 就是要把Float布局拍死在沙滩上 Tips: 布局演变史 1. 表格布局table 世界第一个网页诞生于1990年12月20日, 依赖HTML中的标签来实现 页面随着内容的不断增加, 会变更越来越臃肿, 难以维护 2. 定位布局positon 随着页面复杂度的不断提升, 更多的属性被添加到HTML, CSS中 其中, CSS中的position属性具有革命性 使页面中的元素可以摆脱表格单元格的束缚,可以定位到窗口中的任何位置 3. 浮动布局float 浮动float技术的初衷并不是为了布局, 而是用来处理文本与图片的排版问题 因为任何元素一旦浮动就会变成块元素,从而可以设置宽高, 非常适合页面布局 所以, 网页设计师就使用float再配合,,几乎可以完全任何页面布局 但是元素浮动后, 为了防止对它后面的同级元素产生影响, 就必须清除浮动clear 另外, 当元素之间具有层级关系时, 子元素的浮动会导致父元素失去高度 当然浮动千万的问题远不止以上几点,所以,业界一直在寻求一种真正布局技术 4. 弹性布局flex 我们知道,浮动布局很容易实现元素水平居中, 但是垂直居中就非常的困难,实现起来很麻烦 用浮动技术来进行网页布局,是一种\"无心插柳柳成萌\"的结果, 算是一种巧合吧 使用Flex弹性布局, 就是针对浮动布局的所有痛点而生, 元素浮动的后遗症全部解决 所以在Flex容器中, 不能,也没必要更使用float属性,没了浮动当然也不再需要clear Flex有自己的元素垂直对齐解决方案, 所以vertical-align属性也失效 5. 网格布局grid 不得不说, 世间万物就是一个轮回, 曾经那么令人不堪的表格布局,居然回归了 表格布局尽管有那么多的缺点,但是它的优势也非常明显,就是简单, 直观 其实就这一条, 就足以征服所以设计师,简单直观难道不是我们一直追求的目标吗? 如果有一种布局方式, 即有表格的简单直观, 又有弹性盒子的友好体贴, 那该有多好? 这个愿意现在终于实现了, 网格布局(Grid)横空出世 网格布局集美貌与智慧于一身, 同时具备了表格布局与弹性布局的所有优点 这么好的东西, 可惜很多浏览器支持情况不乐观, 移动端支持好一些 但相信, 会有越来越多的浏览器加入到网格布局的行列中, 大家现在学习正当时 Tips: 布局演变史: 表格(table) ==> 定位(position) ==> 浮动(float) ==> 弹性(flex) ==> 网格(grid, 发展中...) 专注之后，始能忘忧...®Python, Ruby, PHP & web前端Copyright © Mr. Yao all right reserved, powered by skyFimodified at 2020-04-15 22:18:39 "},"CSS布局/Flex弹性布局/3_Flex基本概念.html":{"url":"CSS布局/Flex弹性布局/3_Flex基本概念.html","title":"2.2.3.Flex基本概念","keywords":"","body":"Flex基本概念 资源来源于网络 基本术语 Flex容器(flex container): 采用flex布局的元素, 称为flex容器, 简称容器 Flex项目(flex item): Flex容器中的所有成员(子元素)会自动成为该容器的成员,称为flex项目,简称项目 flex项目都支持宽高设置, 哪怕它之前是内联元素,类似于浮动元素 /*flex容器*/ .contaier { display: flex; } /*flex项目*/ .item { ... } ... item1 item2 item3 主轴(main axis): 也叫水平轴, 横轴,x轴 main start: 起始位置 main end: 结束位置 main size: 单个项目占据的主轴空间 交叉轴(cross axis): 也叫垂直轴,坚轴,y轴 cross start: 起始位置 cross end: 结束位置 cross size: 单个项目占据的交叉轴空间 专注之后，始能忘忧...®Python, Ruby, PHP & web前端Copyright © Mr. Yao all right reserved, powered by skyFimodified at 2020-04-15 22:18:44 "},"CSS布局/Flex弹性布局/4_Flex容器属性.html":{"url":"CSS布局/Flex弹性布局/4_Flex容器属性.html","title":"2.2.4.Flex容器属性","keywords":"","body":"Flex容器属性 资源来源于网络 容器属性汇总: 序号 属性 描述 1 flex-direction 主轴方向(即项目排列方向) 2 flex-wrap 当多个项目在一行排列不下时,如何换行 3 flex-flow flex-direction,flex-wrap的简写,默认:row nowrap 4 justify-content 项目在主轴上对齐方式 5 align-items 项目在交叉轴上的对齐方式 6 align-content 项目在多根轴线上的对齐方式,只有一根轴线无效 1. flex-direction 功能: 决定项目在主轴上的排列方向 它有四个可能的值: 序号 属性值 描述 1 row 默认值 主轴为水平方向,起点在左边 2 row-reverse 主轴为水平方向, 起点在右边(反转) 3 column 主轴为垂直方向, 起点在上边 4 column-reverse 主轴为垂直方向, 起点在下边 CSS语法: .container { display: flex; flex-direction: row | row-reverse | column | column-reverse; } 示意图: 2. flex-wrap 功能: 多个项目默认排列在一根轴线上,该属性定义了当一根轴线排列不下时,多作的项目的换行方式 序号 属性值 描述 1 nowrap 默认值 不换行 2 wrap 自动换行, 第一行排列不下, 自动转到下一行 3 wrap-reverse 自动反向换行, 第一行显示在下方, 与wrap相反 CSS语法 .container { display: flex; flex-wrap: nowrap | wrap | wrap-reverse; } 属性值说明: nowrap: (默认值)不换行 wrap: 自动换行 wrap-reverse: 自动反向换行 3. flex-flow flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap .container { display: flex; flex-flow: [flex-direction] || [flex-wrap]; /*默认*/ flex-flow: row nowrap; } 4. justity-content 功能: 设置项目在主轴上的对齐方式 CSS语法: .container { display: flex; justify-content: flex-start | flex-end | center | space-between | space-around; } 属性值说明 序号 属性值 描述 1 flex-start 默认值 左对齐 2 flex-end 右对齐 3 center 居中对齐 4 space-between 两端对齐: 项目之间间隔相等 5 space-around 项目两侧间隔相等,即项目之间间隔是项目到两端的二倍 6 space-evenly 平均分配主轴上的剩余空间 示意图: 5. align-items 功能: 该属性设置项目在交叉轴上的对齐方式 CSS语法: .container { display: flex; align-items: flex-start | flex-end | center | baseline | stretch; } 属性值说明: 序号 属性值 描述 1 flex-start 与交叉轴起点对齐, 即: 顶对齐 / 上对齐 2 flex-end 与交叉轴终点对齐, 即: 底对齐 / 下对齐 3 center 与交叉轴中间线对齐, 即: 居中对齐 4 baseline 与项目中第一行文本的基线对齐, 即文本的下边线 5 stretch 默认值 自动伸展到容器的高度(项目未设置高度或将高度设置为auto有效) 示意图: 6. align-content align-items和align-content有相同的功能，不过不同点是它是用来让每一个单行的容器居中而不是让整个容器居中 align-content属性只适用于多行的flex容器，并且当交叉轴上有多余空间使flex容器内的flex线对齐 align-items属性适用于所有的flex容器，它是用来设置每个flex元素在交叉轴上的默认对齐方式 该属性的重点,在于多行项目, 这是与align-items最重要的区别 CSS语法: .container { display: flex; align-content: flex-start | flex-end | center | space-between | space-around | stretch; } 属性值说明: 序号 属性值 描述 1 flex-start 与交叉轴起点对齐 2 flex-end 与交叉轴终点对齐 3 center 与交叉轴中间点对齐 4 space-between 与交叉轴两端对齐, 轴线之间间隔相等 5 sapce-around 每根轴线间隔相等,轴线间隔比轴线到边框大一倍 6 stretch 默认值 轴线占满整个交叉轴 示意图: 总结 一个弹性盒子容器的默认状态如下: .container { /*弹性布局*/ display: flex; /*以下弹性盒子容器全部属性以及默认值,即弹性盒子的默认状态*/ /*1. 主轴方向: 行(水平)*/ flex-direction: row; /*2. 多个项目换行方式: 不换行*/ flex-wrap: nowrap; /*3. 多个项目在主轴上的排列与换行方式的简写*/ flex-flow: row nowrap; /*4. 多个项目在主轴上的对齐方式: 左对齐*/ justify-content: flex-start; /*5. 多个项目在交叉轴上的对齐方式: 自动伸展到容器高度*/ align-item: stretch; /*6. 多个项目分为多行时, 在交叉轴上排列方式: 充满整个交叉轴*/ align-content: stretch; } 专注之后，始能忘忧...®Python, Ruby, PHP & web前端Copyright © Mr. Yao all right reserved, powered by skyFimodified at 2020-04-15 22:18:49 "},"CSS布局/Flex弹性布局/5_Flex项目属性.html":{"url":"CSS布局/Flex弹性布局/5_Flex项目属性.html","title":"2.2.5.Flex项目属性","keywords":"","body":" 资源来源于网络 Flex项目属性 巧合的是, 在Flex项目也有6个可用的属性,他们分别是: 序号 属性 描述 1 order 定义项目排列顺序,索引越小超靠前,默认为0 2 flex-grow 定义项目的放大比例,默认为0表示不放大, 即就算存在剩余空间也不放大 3 flex-shrink 定义了项目的缩小比例,默认为1,即如何空间不足,则自动缩小项目来填充 4 flex-basis 定义了项目占据的主轴空间,默认值为auto, 即项目原始大小 5 flex 是flex-grow,flex-shrink,flex-basis简写,默认值: 0 1 auto, 后二个属性可选 6 align-self 个性化定定制某单个项目的对齐方式,可覆盖容器align-items属性,默认auto 1. order 定义项目的排列顺序。数值越小，排列越靠前，默认为0 CSS语法: .item { order: integer; } 示意图: 2. flex-grow 设置项目的放大比例, 默认为0: 不放大,哪怕轴上有剩余空间 CSS语法: .item { flex-grow: number; /* default: 0 */ } 空间分配方案小案例: flex-grow: 1: 每个项目等分, 都占全部的空间的N分之一(N: 项目数量) flex-grow: 2如果某个项目为2, 其它项目为1, 则它占据空间比其它项目多一倍 3. flex-shrink 设置了项目的缩小比例,默认为1, 即空间不足时, 自动缩小填充 CSS语法: .item { flex-shrink: number; /*defautl: 1*/ } 缩放规则 flex-shrink: 1: 所有项目都为1, 空间不足时, 自动等比例缩小填充主轴剩余空间 flex-shrink: 如果有一个项目为0, 其它项目为1, 则空间不足时, 它并不随其它项目缩小 注意: 该属性不支持负值, 即flex-shrink: -1 无效 4. flex-basis 定义了在计算分配主轴上剩余空间之前, 项目占据的主轴空间(main size) 浏览器根据该属性,可以计算出主轴上是否还有剩余空间, 决定是否换行 默认值为auto, 即项目原来占据的空间大小 CSS语法: .item { flex-basis: length | auto; /* default auto */ } 你可以设置与height或者width属性一样的绝对值,例如500px,则该项目占据固定的空间大小 .item { flex-basis: 500px; } 5. flex flex属性是前面flex-grow,flex-shrink和flex-basis属性的简写 默认值: 0 1 auto, 除第一个外, 其它二个可选 CSS语法: .item { flex: none | [ ? || ] } 由于该属性极其常用, 为了简化, Flex布局还为该属性设置了快捷值 flex: auto: 等价于flex: 1 1 auto flex: none: 等价于flex: 0 0 auto 推荐优先使用flex属性, 由浏览器自动计算出其它属性的值 6. align-self 该属性允许单个项目有与其它项目不一样的对齐方式, 可覆盖掉容器的flex-items属性 默认值: auto,表示继承父元素的align-items,如果没有父元素,则等价于stretch CSS语法: .item { align-self: auto | flex-start | flex-end | center | baseline | stretch; } 示意图: 专注之后，始能忘忧...®Python, Ruby, PHP & web前端Copyright © Mr. Yao all right reserved, powered by skyFimodified at 2020-04-15 22:19:01 "},"CSS布局/Grid网格布局/":{"url":"CSS布局/Grid网格布局/","title":"2.3.Grid网格布局","keywords":"","body":"Grid网格布局 资源来源于网络 1.简介 2.基本术语 3.容器属性 4.项目属性 5.经典布局 专注之后，始能忘忧...®Python, Ruby, PHP & web前端Copyright © Mr. Yao all right reserved, powered by skyFimodified at 2020-04-15 22:16:40 "},"CSS布局/Grid网格布局/1_Grid网格布局简介.html":{"url":"CSS布局/Grid网格布局/1_Grid网格布局简介.html","title":"2.3.1.简介","keywords":"","body":"Grid风格布局 资源来源于网络 CSS 网格布局(Grid Layout) 是CSS中最强大的布局系统。 这是一个二维系统，这意味着它可以同时处理列和行，不像 flexbox 那样主要是一维系统。 你可以通过将CSS规则应用于父元素（成为网格容器）和该元素的子元素（网格元素），来使用网格布局。 1. 引言 CSS网格布局（又名“网格”）是一个二维的基于网格的布局系统，其目的只在于完全改变我们设计基于网格的用户界面的方式。 CSS一直用来布局网页，但一直都不完美。 一开始我们使用table 做布局，然后转向浮动、定位以及inline-block，但所有这些方法本质上都是 Hack 的方式，并且遗漏了很多重要的功能（例如垂直居中）。 Flexbox的出现在一定程度上解决了这个问题，但是它的目的是为了更简单的一维布局，而不是复杂的二维布局（Flexbox和Grid实际上一起工作得很好）。 Grid是第一个专门为解决布局问题而生的CSS模块 雷切尔·安德鲁（Rachel Andrew）的书为CSS Grid布局准备。 这本书对网格布局做了彻底、清晰的介绍，也是是整篇文章的基础，我强烈建议你购买并阅读他的书。 我的另一个重要灵感是Chris Coyier的Flexbox完全指南，当需要查阅 flexbox 的一切资料时我就会找这篇文章。 2. 基础知识以及浏览器支持情况 一开始你需要使用display：grid把容器元素定义为一个网格，使用grid-template-columns和grid-template-rows设置列和行大小，然后使用grid-column 和 grid-row把它的子元素放入网格。 与flexbox类似，网格子元素的原始顺序不重要。 你的可以在 CSS 里以任意顺序放置它们，这使得使用媒体查询重新排列网格变得非常容易。 想象一下，我们需要定义整个页面的布局，然后为了适应不同的屏幕宽度完全重新排列，我们只需要几行CSS就能实现这个需求。 网格是有史以来最强大的CSS模块之一。 截至2017年3月，许多浏览器都提供了原生的、不加前缀的对CSS Grid的支持，比如 Chrome（包括Android），Firefox，Safari（包括iOS）和Opera。 另一方面，Internet Explorer 10和11支持它，但需要使用过时的语法。 Edge浏览器已经宣布将支持标准的Grid语法，但暂未支持 桌面浏览器: Chrome Opera Firefox IE Edge Safari 57 44 52 11* 16 10.1移动端 / 平板 移动端 / 平板 iOS Safari Opera Mobile Opera Mini Android Android Chrome Android Firefox 10.3 No No 62 62 57 在生产环境中使用Grid只是时间问题，但现在是我们该学习的时候了 专注之后，始能忘忧...®Python, Ruby, PHP & web前端Copyright © Mr. Yao all right reserved, powered by skyFimodified at 2020-04-15 22:19:25 "},"CSS布局/Grid网格布局/2_Grid常用术语.html":{"url":"CSS布局/Grid网格布局/2_Grid常用术语.html","title":"2.3.2.常用术语","keywords":"","body":" 资源来源于网络 重要术语 在深入了解网格的概念之前，理解术语是很重要的。 由于这里所涉及的术语在概念上都是相似的，如果不先记住它们在网格规范中定义的含义，则很容易将它们彼此混淆。 但是不用太担心，这些术语并不多。 1 网格容器Grid Container 设置了 display: gird 的元素。 这是所有 grid item 的直接父项。 在下面的例子中，.container 就是是 grid container。 2 网格项目Grid Item Grid 容器的孩子（直接子元素）。下面的 .item 元素就是 grid item，但 .sub-item不是 3 网格线Grid Line 这个分界线组成网格结构。 它们既可以是垂直的（“column grid lines”），也可以是水平的（“row grid lines”），并位于行或列的任一侧。 下面例中的黄线就是一个列网格线 4 网格轨道Grid Track 两个相邻网格线之间的空间。 你可以把它们想象成网格的列或行。 下面是第二行和第三行网格线之间的网格轨道 5 网格单元Grid Cell 两个相邻的行和两个相邻的列网格线之间的空间。它是网格的一个“单元”。 下面是行网格线1和2之间以及列网格线2和3的网格单元。 6 网格区域Grid Area 四个网格线包围的总空间。 网格区域可以由任意数量的网格单元组成。 下面是行网格线1和3以及列网格线1和3之间的网格区域 7. Grid 属性列表 7.1 Grid Container 的全部属 display grid-template-columns grid-template-rows grid-template-areas grid-template grid-column-gap grid-row-gap grid-gap justify-items align-items justify-content align-content grid-auto-columns grid-auto-rows grid-auto-flow grid 7.2 Grid Items 的全部属性 grid-column-start grid-column-end grid-row-start grid-row-end grid-column grid-row grid-area justify-self align-self 专注之后，始能忘忧...®Python, Ruby, PHP & web前端Copyright © Mr. Yao all right reserved, powered by skyFimodified at 2020-04-15 22:19:33 "},"CSS布局/Grid网格布局/3_Grid容器属性.html":{"url":"CSS布局/Grid网格布局/3_Grid容器属性.html","title":"2.3.3.Grid容器属性","keywords":"","body":" 资源来源于网络 父容器(Grid Container)的属性 1 display 将元素定义为 grid contaienr，并为其内容建立新的网格格式化上下文(grid formatting context)。 值: grid: 生成一个块级(block-level)网格 inline-grid: 生成一个行级(inline-level)网格 subgrid: 如果你的 grid container 本身就是一个 grid item（即,嵌套网格），你可以使用这个属性来表示你想从它的父节点获取它的行/列的大小，而不是指定它自己的大小。 .container { display: grid | inline-grid | subgrid; } 注意：column, float, clear, 以及 vertical-align 对一个 grid container 没有影响 2 grid-template-columns / grid-template-rows 使用以空格分隔的多个值来定义网格的列和行。这些值表示轨道大小(track size)，它们之间的空格代表表格线(grid line)。 .container { grid-template-columns: ... | ...; grid-template-rows: ... | ...; } 例子: (如果未显示的给网格线命名)，轨道值之间仅仅有空格时，网格线会被自动分配数字名称： .container { grid-template-columns: 40px 50px auto 50px 40px; grid-template-rows: 25% 100px auto; } 但你可以给网格线指定确切的命名。 注意中括号里的网格线命名语法： .container { grid-template-columns: [first] 40px [line2] 50px [line3] auto [col4-start] 50px [five] 40px [end]; grid-template-rows: [row1-start] 25% [row1-end] 100px [third-line] auto [last-line]; } 需要注意的是，一个网格线可以有不止一个名字。例如，这里第2条网格线有两个名字：row1-end 和 row2-start： .container { grid-template-rows: [row1-start] 25% [row1-end row2-start] 25% [row2-end]; } 如果你的定义中包含重复的部分，则可以使用repeat() 符号来简化写法： .container { grid-template-columns: repeat(3, 20px [col-start]) 5%; } /* 等价于 */ .container { grid-template-columns: 20px [col-start] 20px [col-start] 20px [col-start] 5%; } “fr”单位允许您将轨道大小设置为网格容器自由空间的一部分。 例如，下面的代码会将每个 grid item 为 grid container 宽度的三分之一： .container { grid-template-columns: 1fr 1fr 1fr; } 自由空间是在排除所有不可伸缩的 grid item 之后计算得到的。 在下面的示例中，fr单位可用的自由空间总量不包括50px: .container { grid-template-columns: 1fr 50px 1fr 1fr; } 3. grid-template-areas 通过引用 grid-area属性指定的网格区域的名称来定义网格模板。 重复网格区域的名称导致内容扩展到这些单元格。 点号表示一个空单元格。 语法本身提供了网格结构的可视化。 值： – 使用 grid-area 属性设置的网格区域的名称 . – 点号代表一个空网格单元 none – 没有定义网格区域 举例： .item-a { grid-area: header; } .item-b { grid-area: main; } .item-c { grid-area: sidebar; } .item-d { grid-area: footer; } .container { grid-template-columns: 50px 50px 50px 50px; grid-template-rows: auto; grid-template-areas: \"header header header header\" \"main main . sidebar\" \"footer footer footer footer\"; } 这将创建一个四列宽三行高的网格。 整个第一行将由 header 区域组成。 中间一行将由两个 main 区域、一个空单元格和一个 sidebar 区域组成。 最后一行是footer区域组成。 你的声明中的每一行都需要有相同数量的单元格。 您可以使用任意数量的相邻的.来声明单个空单元格。 只要这些点号之间没有空格，他们就代表了一个单一的单元格。 需要注意的是你不是在用这个语法命名网格线，而是在命名区域。 当你使用这种语法时，区域两端的网格线实际上是自动命名的。 比如，如果网格区域的名称是foo，那么区域的起始的行网格线和列网格线名称是 foo-start，并且区域终点的行网格线和列网格线名称是 foo-end。 这意味着某些网格线可能有多个名称，比如上面的例子中最左边的一条网格线有三个名字：header-start，main-start 和 footer-start。 4. grid-template 在单个声明中定义 grid-template-rows、grid-template-columns、grid-template-areas 的简写。 值： none – 将三个属性都设置为其初始值 subgrid – 把 grid-template-rows 和 grid-template-columns 设置为 subgrid, 并且 grid-template-areas 设置为初始值 grid-template-rows / – 把 grid-template-columns 和 grid-template-rows 设置为指定值, 与此同时, 设置 grid-template-areas 为 none .container { grid-template: none | subgrid | / ; } 它也可以使用一个更复杂但相当方便的语法来指定这三个值。 一个例子： .container { grid-template: [row1-start] \"header header header\" 25px [row1-end] [row2-start] \"footer footer footer\" 25px [row2-end] / auto 50px auto; } /* 等价于 */ .container { grid-template-rows: [row1-start] 25px [row1-end row2-start] 25px [row2-end]; grid-template-columns: auto 50px auto; grid-template-areas: \"header header header\" \"footer footer footer\"; } 由于 grid-template 不会重置隐式网格属性（grid-auto-columns，grid-auto-rows和grid-auto-flow），而这可能是大多数情况下你想要做的。因此建议使用grid属性来代替grid-template。 5. grid-column-gap / grid-row-gap 指定网格线的大小，你可以把它想象为设置列/行之间的间距的宽度。 值： line-size – 一个长度值 .container { grid-column-gap: ; grid-row-gap: ; } 举例： .container { grid-template-columns: 100px 50px 100px; grid-template-rows: 80px auto 80px; grid-column-gap: 10px; grid-row-gap: 15px; } 只能在列/行之间创建缝隙，而不是在外部边缘创建 6. grid-gap grid-row-gap 和 grid-column-gap 的缩写 .container { grid-gap: ; } Example: .container { grid-template-columns: 100px 50px 100px; grid-template-rows: 80px auto 80px; grid-gap: 10px 15px; } 如果没有指定 grid-row-gap，则会被设置为与 grid-column-gap 相同的值。 7. justify-items 沿着行轴对齐网格内的内容（与之对应的是 align-items, 即沿着列轴对齐），该值适用于容器内的所有的 grid items。 值： start: 内容与网格区域的左端对齐 end: 内容与网格区域的右端对齐 center: 内容位于网格区域的中间位置 stretch: 内容宽度占据整个网格区域空间(这是默认值) .container { justify-items: start | end | center | stretch; } 举例： .container { justify-items: start; } .container{ justify-items: end; } .container { justify-items: center; } .container { justify-items: stretch; } 也可以通过给单个 grid item 设置justify-self属性来达到上述效果。 8. align-items 沿着列轴对齐grid item 里的内容（与之对应的是使用 justify-items 设置沿着行轴对齐），该值适用于容器内的所有 grid items。 值： start: 内容与网格区域的顶端对齐 end: 内容与网格区域的底部对齐 center: 内容位于网格区域的垂直中心位置 stretch: 内容高度占据整个网格区域空间(这是默认值) .container { align-items: start | end | center | stretch; } 举例: .container { align-items: start; } .container { align-items: end; } .container { align-items: center; } .container { align-items: stretch; } 也可以通过给单个 grid item 设置align-self属性来达到上述效果。 9. justify-content 有时，网格的总大小可能小于其网格容器的大小。如果你的所有 grid items 都使用像px这样的非弹性单位来设置大小，则可能发生这种情况。此时，你可以设置网格容器内的网格的对齐方式。 此属性沿着行轴对齐网格（与之对应的是 align-content, 沿着列轴对齐）。 值： start – 网格与网格容器的左边对齐 end – 网格与网格容器的右边对齐 center – 网格与网格容器的中间对齐 stretch – 调整g rid item 的大小，让宽度填充整个网格容器 space-around – 在 grid item 之间设置均等宽度的空白间隙，其外边缘间隙大小为中间空白间隙宽度的一半 space-between – 在 grid item 之间设置均等宽度空白间隙，其外边缘无间隙 space-evenly – 在每个 grid item 之间设置均等宽度的空白间隙，包括外边缘 .container { justify-content: start | end | center | stretch | space-around | space-between | space-evenly; } 举例： .container { justify-content: start; } .container { justify-content: end; } .container { justify-content: center; } .container { justify-content: stretch; } .container { justify-content: space-around; } .container { justify-content: space-between; } .container { justify-content: space-evenly; } 10. align-content 有时，网格的总大小可能小于其网格容器的大小。如果你的所有 grid items 都使用像px这样的非弹性单位来设置大小，则可能发生这种情况。此时，你可以设置网格容器内的网格的对齐方式。 此属性沿着列轴对齐网格（与之对应的是 justify-content, 即沿着行轴对齐）。 值： start – 网格与网格容器的顶部对齐 end – 网格与网格容器的底部对齐 center – 网格与网格容器的中间对齐 stretch – 调整 grid item 的大小，让高度填充整个网格容器 space-around – 在 grid item 之间设置均等宽度的空白间隙，其外边缘间隙大小为中间空白间隙宽度的一半 space-between – 在 grid item 之间设置均等宽度空白间隙，其外边缘无间隙 space-evenly – 在每个 grid item 之间设置均等宽度的空白间隙，包括外边缘 .container { align-content: start | end | center | stretch | space-around | space-between | space-evenly; } 举例： .container { align-content: start; } .container { align-content: end; } .container { align-content: center; } .container { align-content: stretch; } .container { align-content: space-around; } .container { align-content: space-between; } .container { align-content: space-evenly; } 11. grid-auto-columns / grid-auto-rows 指定自动生成的网格轨道（又名隐式网格轨道）的大小。 隐式网格轨道在你显式的定位超出指定网格范围的行或列（使用 grid-template-rows/grid-template-columns）时被创建。 值： – 可以是一个长度值，一个百分比值，或者一个自由空间的一部分（使用 fr 单位） .container { grid-auto-columns: ...; grid-auto-rows: ...; } 为了说明如何创建隐式网格轨道，思考如下代码： .container { grid-template-columns: 60px 60px; grid-template-rows: 90px 90px } 这里创建了一个 2×2的网格。 但是，现在想象一下，使用 grid-column 和 grid-row 来定位你的网格项目，如下所示： .item-a { grid-column: 1 / 2; grid-row: 2 / 3; } .item-b { grid-column: 5 / 6; grid-row: 2 / 3; } 这里我们指定 .item-b开始于列网格线 5 并结束于在列网格线 6，但我们并未定义列网格线 5 或 6。因为我们引用不存在的网格线，宽度为0的隐式轨道的就会被创建用与填补间隙。我们可以使用 grid-auto-columns 和 grid-auto-rows属性来指定这些隐式轨道的宽度： .container { grid-auto-columns: 60px; } 12. grid-auto-flow 如果你存在没有显示指明放置在网格上的 grid item，则自动放置算法会自动放置这些项目。 而该属性则用于控制自动布局算法的工作方式。 值： row – 告诉自动布局算法依次填充每行，根据需要添加新行 column – 告诉自动布局算法依次填充每列，根据需要添加新列 dense – 告诉自动布局算法，如果后面出现较小的 grid item，则尝试在网格中填充空洞 .container { grid-auto-flow: row | column | row dense | column dense } 需要注意的是，dense 可能导致您的 grid item 乱序。 举例， 考虑如下 HTML： item-a item-b item-c item-d item-e 当把 grid item 放在网格上时，你只把其中两个设置了固定的位置： .item-a { grid-column: 1; grid-row: 1 / 3; } .item-e { grid-column: 5; grid-row: 1 / 3; } 因为我们将 grid-auto-flow 设置为row，所以我们的grid就像这样。 注意观察我们没有做设置的三个项目（item-b，item-c和item-d）是如何在剩余的行水平摆放位置的： 如果我们将 grid-auto-flow 设置为 column，则 item-b，item-c 和 item-d 以列的顺序上下摆放： 13. grid 在单个属性中设置所有以下属性的简写：grid-template-rows，grid-template-columns，grid-template-areas，grid-auto-rows，grid-auto-columns和grid-auto-flow。 它同时也将 sets grid-column-gap 和 grid-row-gap 设置为它们的初始值，即使它们不能被此属性显示设置。 值： none – 将所有子属性设置为其初始值 / – 将 grid-template-rows 和 grid-template-columns 分别设置为指定值，将所有其他子属性设置为其初始值 [ [ / ] ] – 接受所有与grid-auto-flow，grid-auto-rows和grid-auto-columns相同的值。 如果省略grid-auto-columns，则将其设置为为grid-auto-rows指定的值。 如果两者都被省略，则它们被设置为它们的初始值 .container { grid: none | / | [ [/ ]]; } 举例： 以下代码写法等价 .container { grid: 200px auto / 1fr auto 1fr; } .container { grid-template-rows: 200px auto; grid-template-columns: 1fr auto 1fr; grid-template-areas: none; } 以下代码写法等价 .container { grid: column 1fr / auto; } .container { grid-auto-flow: column; grid-auto-rows: 1fr; grid-auto-columns: auto; } 它也可用使用一个更复杂但相当方便的语法来一次设置所有内容。 你可以指定 grid-template-areas、grid-template-rows 以及 grid-template-columns，并将所有其他子属性设置为其初始值。 你现在所做的是在其网格区域内，指定网格线名称和内联轨道大小。 可以看下面的例子： .container { grid: [row1-start] \"header header header\" 1fr [row1-end] [row2-start] \"footer footer footer\" 25px [row2-end] / auto 50px auto; } 上述代码等价于 .container { grid-template-areas: \"header header header\" \"footer footer footer\"; grid-template-rows: [row1-start] 1fr [row1-end row2-start] 25px [row2-end]; grid-template-columns: auto 50px auto; } 专注之后，始能忘忧...®Python, Ruby, PHP & web前端Copyright © Mr. Yao all right reserved, powered by skyFimodified at 2020-04-15 22:19:48 "},"CSS布局/Grid网格布局/4_Grid项目属性.html":{"url":"CSS布局/Grid网格布局/4_Grid项目属性.html","title":"2.3.4.Grid项目属性","keywords":"","body":" 资源来源于网络 Grid Items 属性 1. grid-column-start / grid-column-end / grid-row-start /grid-row-end 使用特定的网格线确定 grid item 在网格内的位置。grid-column-start/grid-row-start 属性表示grid item的网格线的起始位置，grid-column-end/grid-row-end属性表示网格项的网格线的终止位置。 值： : 可以是一个数字来指代相应编号的网格线，也可使用名称指代相应命名的网格线 span : 网格项将跨越指定数量的网格轨道 span : 网格项将跨越一些轨道，直到碰到指定命名的网格线 auto: 自动布局， 或者自动跨越， 或者跨越一个默认的轨道 .item { grid-column-start: | | span | span | auto grid-column-end: | | span | span | auto grid-row-start: | | span | span | auto grid-row-end: | | span | span | auto } 举例： .item-a { grid-column-start: 2; grid-column-end: five; grid-row-start: row1-start grid-row-end: 3 } .item-b { grid-column-start: 1; grid-column-end: span col4-start; grid-row-start: 2 grid-row-end: span 2 } 如果没有声明 grid-column-end / grid-row-end，默认情况下，该网格项将跨越1个轨道。 网格项可以相互重叠。 您可以使用z-index来控制它们的堆叠顺序。 2. grid-column / grid-row grid-column-start + grid-column-end, 和 grid-row-start + grid-row-end 的简写形式。 值： / – 每个值的用法都和属性分开写时的用法一样 .item { grid-column: / | / span ; grid-row: / | / span ; } 举例： .item-c { grid-column: 3 / span 2; grid-row: third-line / 4; } 如果没有指定结束行值，则该网格项默认跨越1个轨道。 3. grid-area 给 grid item 进行命名以便于使用 grid-template-areas 属性创建模板时来进行引用。另外也可以做为 grid-row-start + grid-column-start + grid-row-end + grid-column-end 的简写形式。 值： – 你的命名 / / / – 可以是数字，也可以是网格线的名字 .item { grid-area: | / / / ; } 举例: 给一个网格项命名 .item-d { grid-area: header } 作为 grid-row-start + grid-column-start + grid-row-end + grid-column-end 的简写: .item-d { grid-area: 1 / col4-start / last-line / 6 } 4. justify-self 沿着行轴对齐grid item 里的内容（与之对应的是 align-self, 即沿列轴对齐）。 此属性对单个网格项内的内容生效。 值： start – 将内容对齐到网格区域的左端 end – 将内容对齐到网格区域的右端 center – 将内容对齐到网格区域的中间 stretch – 填充网格区域的宽度 (这是默认值) 举例： .item-a { justify-self: start; } .item-a { justify-self: end; } .item-a { justify-self: center; } 要为网格中的所有grid items 设置对齐方式，也可以通过 justify-items 属性在网格容器上设置此行为。 5. align-self 沿着列轴对齐grid item 里的内容（与之对应的是 justify-self, 即沿行轴对齐）。 此属性对单个网格项内的内容生效。 值： start – 将内容对齐到网格区域的顶部 end – 将内容对齐到网格区域的底部 center – 将内容对齐到网格区域的中间 stretch – 填充网格区域的高度 (这是默认值) .item { align-self: start | end | center | stretch; } 举例: .item-a { align-self: start; } .item-a { align-self: end; } .item-a { align-self: center; } .item-a { align-self: stretch; } 要为网格中的所有grid items 统一设置对齐方式，也可以通过 align-items 属性在网格容器上设置此行为。 专注之后，始能忘忧...®Python, Ruby, PHP & web前端Copyright © Mr. Yao all right reserved, powered by skyFimodified at 2020-04-15 22:20:02 "},"CSS布局/Grid网格布局/5_经典的三列布局.html":{"url":"CSS布局/Grid网格布局/5_经典的三列布局.html","title":"2.3.5.经典的三列布局","keywords":"","body":" 资源来源于网络 经典的三列布局 三列布局是基础, 可以方便的扩展为二列或多列 最终效果图 HTML结构 简单的三列布局 头部 左边栏 主体内容区 右边栏 底部 CSS代码 /* style.css */ body { /*设置body元素采用网格布局*/ display: grid; /*行模板: 第一行60px,第二行750px, 第三行60px*/ grid-template-rows: 60px 750px 60px; /*列模板: 第一列200px,第2列自动扩展, 第3列200px*/ grid-template-columns: 200px auto 200px; /*设置行间距:10px*/ grid-row-gap: 10px; /*设置列间距: 10px*/ grid-column-gap: 10px; } .header { /*网格区域命名*/ grid-area: my-header; /*参考背景色*/ background-color: lightgreen; } .footer { /*网格区域命名*/ grid-area: my-footer; /*参考背景色*/ background-color: lightgreen; } .left { /*网格区域命名*/ grid-area: my-left; /*参考背景色*/ background-color: lightblue; } .right { /*网格区域命名*/ grid-area: my-right; /*参考背景色*/ background-color: lightblue; } .content { /*网格区域命名*/ grid-area: my-content; /*参考背景色*/ background-color: coral; } /*设置网格区域: 非常直观*/ body { /*网格区域名称相同, 意味着合并*/ grid-template-areas: \"my-header my-header my-header\" \"my-left my-content my-right\" \"my-footer my-footer my-footer\" } 看到这里不禁老泪纵横,世间万物都有轮回, 谁能料到,江湖上失传近20年的表格布局大法,会以这种方式回归 专注之后，始能忘忧...®Python, Ruby, PHP & web前端Copyright © Mr. Yao all right reserved, powered by skyFimodified at 2020-04-15 22:20:12 "},"CSS布局/Grid网格布局/6_更实用的网格布局.html":{"url":"CSS布局/Grid网格布局/6_更实用的网格布局.html","title":"2.3.6.更实用的网格布局","keywords":"","body":" 资源来源于网络 更实用的风格布局 这是一个较复杂的布局案例, 用到了媒体查询 效果图 原图 分析: HTML结构 首页 top-bar main-header message award blog-posts news side-bar main-footer CSS代码 /* style.css */ body { display: grid; grid-template-columns: 12% auto 400px 12%; grid-template-rows: auto auto 300px auto auto auto; grid-template-areas: \"top-bar top-bar top-bar top-bar\" \"main-header main-header main-header main-header\" \"hero hero hero hero\" \". blog-posts side-bar .\" \". news side-bar .\" \"main-footer main-footer main-footer main-footer\"; margin: 0; font-size: 1.5rem; } .top-bar{ /*区域命名*/ grid-area: top-bar; background-color: lightblue; padding: 4px 12%; } .main-header{ grid-area: main-header; background-color: lightcoral; padding: 12px 12%; } .hero{ grid-area: hero; background: lightseagreen; padding: 55px 12% 0 12%; display: grid; grid-template-columns: auto 1fr auto; grid-template-rows: auto auto auto; grid-template-areas: \". . award\" \"message . . \" \". . . \"; } .blog-posts{ grid-area: blog-posts; min-height: 200px; background-color: yellowgreen; } .news{ grid-area: news; min-height: 200px; background-color: cyan; } .side-bar{ grid-area: side-bar; background: #0e8; } .main-footer{ grid-area: main-footer; background-color: lightblue; padding: 25px 12%; } .message{ grid-area: message; } .award{ grid-area: award; } /*媒体查询*/ @media (max-width: 1600px) { body{ grid-template-columns: 2% auto 400px 2%; } .top-bar{ padding: 4px 2%; } .main-header{ padding: 12px 2%; } .hero{ padding: 55px 2% 0 2%; } .main-footer{ padding: 25px 2%; } } /*媒体查询*/ @media (max-width: 1050px) { body{ grid-template-columns: 3% auto 3%; grid-template-rows: auto auto auto auto auto auto auto; grid-template-areas: \"top-bar top-bar top-bar\" \"main-header main-header main-header\" \"hero hero hero\" \". blog-posts .\" \". news .\" \". side-bar .\" \"main-footer main-footer main-footer\"; } } 专注之后，始能忘忧...®Python, Ruby, PHP & web前端Copyright © Mr. Yao all right reserved, powered by skyFimodified at 2020-04-15 22:20:20 "},"其他/":{"url":"其他/","title":"3.其他","keywords":"","body":"其他 静态资源压缩 gh-pages 部署 webpack 的简单使用 GitBook 的简单使用 专注之后，始能忘忧...®Python, Ruby, PHP & web前端Copyright © Mr. Yao all right reserved, powered by skyFimodified at 2020-04-15 22:12:02 "},"其他/1_静态资源压缩.html":{"url":"其他/1_静态资源压缩.html","title":"3.1.静态资源压缩","keywords":"","body":" 前端的静态资源压缩的方式有很多，这里记录一下 Grunt 和 Gulp 的使用 1. Grunt压缩 Grunt3是基于NodeJS的一个自动化压缩、合并、测试等构建工具，可用npm安装，任务文件Gruntfile.js放在项目的根目录下。 1.1.安装 npm install -g grunt-cli 1.2.新建 package.json 文件内容如下： { \"name\": \"project-name\", \"version\": \"1.0.0\", // ... \"devDependencies\": { \"grunt\": \"^0.4.5\", \"grunt-contrib-concat\": \"^1.0.0\", \"grunt-contrib-cssmin\": \"^0.12.3\", \"grunt-contrib-imagemin\": \"^1.0.0\", \"grunt-contrib-jshint\": \"^0.12.0\", \"grunt-contrib-nodeunit\": \"~0.4.1\", \"grunt-contrib-uglify\": \"^0.5.1\" } } 1.3.安装依赖 执行命令: npm install 1.4.新建 Gruntfile.js 添加配置任务，如： module.exports = function(grunt) { grunt.initConfig({ pkg: grunt.file.readJSON('package.json'), //压缩 js uglify: { options: { banner: '/*压缩文件声明文本...*/\\n' }, build:{ files:[{ src: ['a.js', 'b.js', 'c.js'], dest: 'abc.min.js' //合并压缩后生成的文件 },{ src: ['d.js'], dest: 'd.min.js' }] } }, //压缩 css cssmin: { options: { keepSpecialComments: 0 }, compress: { files: [{ src: [\"a.css\", \"b.css\"], dest: 'ab.min.css' //合并压缩后生成的文件 },{ src: ['c.css'], dest: 'c.min.css' }] } }, //压缩 图片 imagemin: { /* 压缩图片大小 */ dist: { options: { optimizationLevel: 3 //定义 PNG 图片优化水平 }, files: [{ expand: true, cwd: 'images', src: ['**/*.{png,jpg,jpeg}'], // 优化 img 目录下所有 png/jpg/jpeg 图片 dest: 'images' // 优化后的图片保存位置，覆盖旧图片，并且不作提示（建议新建一个目录） }] } } }); /* 加载任务插件 */ grunt.loadNpmTasks('grunt-contrib-uglify'); grunt.loadNpmTasks('grunt-contrib-cssmin'); grunt.loadNpmTasks('grunt-contrib-imagemin'); /* 默认被执行的任务列表 */ grunt.registerTask('default', ['uglify', 'cssmin', 'imagemin]); }; 2. Gulp压缩 2.1.安装 npm install gulp -g # or npm install gulp-cli -g 2.2.新建 package.json 文件 添加依赖项： { \"name\": \"project-name\", \"version\": \"1.0.0\", // ... \"devDependencies\": { \"gulp\": \"^4.0.2\", \"gulp-autoprefixer\": \"^3.1.0\", \"gulp-minify-css\": \"^1.2.1\", \"gulp-rename\": \"^1.2.2\", \"gulp-htmlclean\": \"^2.7.22\", \"gulp-htmlmin\": \"^5.0.1\", \"gulp-uglify\": \"^3.0.2\", \"babel-core\": \"^6.26.3\", \"gulp-babel\": \"^7.0.1\", \"gulp-imagemin\": \"^7.1.0\", \"gulp-sass\": \"^4.0.2\" }, } 2.3.安装依赖 执行命令： npm install 2.4.新建 gulpfile.js 文件 添加任务配置，如： var gulp = require('gulp'); var sass = require('gulp-sass'); var prefix = require('gulp-autoprefixer'); var minifyCSS = require('gulp-minify-css'); var rename = require('gulp-rename'); var htmlmin = require('gulp-htmlmin'); var htmlclean = require('gulp-htmlclean'); var babel = require('gulp-babel'); var uglify = require('gulp-uglify'); var imagemin = require('gulp-imagemin'); // 压缩 html gulp.task('minify-html', function() { return gulp.src('./*.html') .pipe(htmlclean()) .pipe(htmlmin({ removeComments: true, minifyJS: true, minifyCSS: true, minifyURLs: true, })) .pipe(gulp.dest('./public')); done(); }); // 压缩 css gulp.task('compressCSS', function() { return gulp.src(['src/css/*.scss','src/css/*.css']) .pipe(sass()) .pipe(prefix(['last 15 versions', '> 1%', 'ie 8', 'ie 7'], { cascade: true })) .pipe(minifyCSS()) .pipe(rename({ suffix: '.min' })) .pipe(gulp.dest('./public/src/css/')) .pipe(browserSync.stream()); done(); }); // 压缩 js gulp.task('minify-js', function (done) { return gulp.src(['src/js/*.js']) .pipe(uglify()) .pipe(gulp.dest('./public/src/js/')); done(); }); // 压缩 图片 gulp.task('minify-images', function() { return gulp.src('*.ico', 'src/img/*.*') .pipe(imagemin( [imagemin.gifsicle({'optimizationLevel': 3}), imagemin.optipng({'optimizationLevel': 7}), imagemin.svgo()], {'verbose': true})) .pipe(gulp.dest('./public/src/images')) }); gulp.task('font', function (done) { return gulp.src(['./font/*']) .pipe(gulp.dest('./public/font')); done(); }); gulp.task('default',gulp.series(gulp.parallel('compressCSS','minify-js', 'minify-images', 'font', 'minify-html')), function () { console.log(\"----------gulp Finished----------\"); // Do something after a, b, and c are finished. }); 另外，其他同类插件的使用，可参考：fis3使用、gzip压缩、Webpack 构建前端资源 参考： [1]. Web前端性能优化实践 [2]. Gruntjs 压缩合并前端静态资源 专注之后，始能忘忧...®Python, Ruby, PHP & web前端Copyright © Mr. Yao all right reserved, powered by skyFimodified at 2020-04-13 23:18:35 "},"其他/2_gh-pages部署到GitHub.html":{"url":"其他/2_gh-pages部署到GitHub.html","title":"3.2.gh-pages 部署","keywords":"","body":"有时需要将一些前端静态资源部署到GitHub上，如博客、在线简历这类的情况。 这只涉及一些简单的页面和静态文件，为了减少一些脚本的使用，前端有gh-pages这样一个模块，可以帮助部署到GitHub上。 1.注册 GitHub 账号 确保有一个GitHub账号，新建仓库，并设置与本地关联，具体步骤参考网上的资料。 2.创建 gh-pages 分支 为了不影响项目的开发，在 GitHub 上创建一个 gh-pages 分支。 git checkout --orphan gh-pages git remote add origin {远程仓} # 添加关联 git push origin gh-pages # 推送远程 3.安装 node.js 确保有 node 环境，安装 npm，一般安装nodejs的安装包都集成了。 将 node 和 npm 添加到环境变量，具体流程可去网上搜索。 这里推荐一款修改Windows环境变量的软件：rapidee 4.安装插件 gh-pages cd project_path # 进入项目目录 npm install gh-pages --save 5.修改 package.json { //配置homepage \"homepage\":\"https://yaojusheng.github.io/dynamic-resume\", //配置scripts \"scripts\":{ \"dev\": \"node build/dev-server.js\", \"build\": \"node build/build.js\", \"predeploy\":\"npm run build\", \"deploy\":\"gh-pages -d public\" }, } 6.修改 config/index.js build: { ..., assetsPublicPath: '' // 置空 }, 6.推送到 gh-pages 分支 npm run deploy 7.设置 GitHub Pages 的 source 点击项目的 Settings 按钮，找到 GitHub Pages 选项，然后选择之前创建的 gh-pages 分支作为 source，等待部署完成。 专注之后，始能忘忧...®Python, Ruby, PHP & web前端Copyright © Mr. Yao all right reserved, powered by skyFimodified at 2020-04-13 23:19:38 "},"其他/3_webpack的使用.html":{"url":"其他/3_webpack的使用.html","title":"3.3.webpack的使用","keywords":"","body":" webpack 是一款模块加载器兼打包工具，它能够把各种资源，例如js（含JSX）、样式（含less/sass）、图片等都作为模块来使用和处理。 1.简介 Webpack 是一个模块打包器。根据模块的依赖关系进行静态分析，然后按照指定的规则将这些模块生成对应的静态资源。 相比于 gulp、grunt 等构件工具，WebPack 是一种模块化的解决方案，适合一些前后端分离项目的的场景，模块间依赖不强， 而 gulp 等工具侧重于资源压缩和自动化的构建，目前大型项目的开发，可以结合两者，协同工作。 这张官网图片，很好地展示了它的用途： 2.Webpack 的特点 代码拆分 Webpack 有两种组织模块依赖的方式，同步和异步。异步依赖作为分割点，形成一个新的块。在优化了依赖树后，每一个异步区块都作为一个文件被打包。 Loader Webpack 本身只能处理原生的 JavaScript 模块，但是 loader 转换器可以将各种类型的资源转换成 JavaScript 模块。这样，任何资源都可以成为 Webpack 可以处理的模块。 智能解析 Webpack 有一个智能解析器，几乎可以处理任何第三方库，无论它们的模块形式是 CommonJS、 AMD 还是普通的 JS 文件。甚至在加载依赖的时候，允许使用动态表达式 require(\"./templates/\" + name + \".jade\")。 插件系统 Webpack 还有一个功能丰富的插件系统。大多数内容功能都是基于这个插件系统运行的，还可以开发和使用开源的 Webpack 插件，来满足各式各样的需求。 快速运行 Webpack 使用异步 I/O 和多级缓存提高运行效率，这使得 Webpack 能够以令人难以置信的速度快速增量编译。 参考：W3Cschool 3.安装使用 3.1.安装 （1）、确保已安装 Node.js 环境，使用 npm 安装： npm install webpack -g （2）、在项目目录，进行初始化： npm init # 此时会生成 package.json （3）、安装 webpack 依赖： npm install webpack --save-dev （4）、安装 Webpack 开发工具： npm install webpack-dev-server --save-dev 3.2.简单使用 新建一个简单的项目 hello-world，目录结构如下： （1）、index.html 内容如下： Webpack test This is a test Hello Webpack! ---------------------------------------- （2）、module.js 和 test.js 内容如下： // module.js module.exports = 'It works from module.js.' // test.js document.write(require('./module.js')) // 添加模块 document.write('webpack`s work is done.') （3）、package.json 内容如下： { \"name\": \"hello-world\", \"version\": \"1.0.0\", \"description\": \"webpack test\", \"main\": \"test.js\", \"scripts\": { \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\", \"dev\": \"webpack test.js bundle.js\" }, \"author\": \"Mr. Yao\", \"license\": \"ISC\", \"devDependencies\": { \"webpack\": \"^4.42.1\" }, \"dependencies\": {} } （4）、新建 webpack.config.js 文件： module.exports = { // 入口文件 entry: __dirname + \"/test.js\", // // 输出文件 output: { path: __dirname + \"/\", filename: \"bundle.js\" //打包后的输出文件名 }, mode: 'development' } （5）、运行打包命令： npm run dev 页面显示： 4.Webpack 核心 核心概念： 入口(entry)：指示 webpack 应该使用哪个模块，以及模块和库是入口起点 输出(output)：告诉 webpack 在哪里输出它所创建的目标文件，以及如何命名。 加载转换(loader)：让 webpack 能够去处理其他类型的文件，并将它们转换为可识别的模块 插件(plugin)：用于执行范围更广的任务（扩展）。包括：打包优化，资源管理，注入环境变量。 模式(mode)：通过选择 development, production 或 none 之中的一个，来设置 mode 参数 4.1.常用 Loader 样式： css-loader、style-loader、less-loader、sass-loader等 scss 样式处理 // webpack.config.js { // ... module: { rules: [ { test: /\\.scss$/, use:[ {loader:'style-loader'}, {loader:'css-loader',options:{sourceMap:true,modules:true}}, {loader:'sass-loader',options:{sourceMap:true}} ], exclude:/node_modules/ } ] } // ... } postcss-loader/autoprefixer: 浏览器兼容考虑，将前缀补充交由webpack 完成 ```js // postcss.config.js module.exports = { plugins: [ // 需要使用的插件列表 require('autoprefixer'), ] } // webpack.config.js { // ... module:{ rules: [ { test: /.css$/, use: ['style-loader', 'css-loader', 'postcss-loader'] }, // ... ] }, // ... } 2. 文件：`raw-loader`、`file-loader`、`json-loader` 、`url-loader`等 3. 编译：`babel-loader`、`coffee-loader` 、`ts-loader`等 4. 校验：`mocha-loader`、`jshint-loader` 、`eslint-loader`等 > 参考： [webpack之 loader 和 plugin 简介](https://juejin.im/post/5980752ef265da3e2e56e82e) ### 4.2.常用 `plugin` 在配置文件 `webpack.config.js` 中，`plugins` 是一个插件组成的数组。 数组中的插件对象是插件new出来的实例。 **用法**： ```js plugins:[plugin1,plugin2, ...] e.g.： plugins: [ new webpack.optimize.UglifyJsPlugin(), new HtmlWebpackPlugin({template: './public/index.html'}) ] 4.2.1.HTML文件生成插件(html-webpack-plugin) 作用：HtmlWebpackPlugin 在此可以用于自动重新生成一个index.html或依据模板生成，帮你把所有生产的js文件引入到html中，最终生成到output目录。 安装： npm install --save-dev html-webpack-plugin 配置: //引入 const HtmlWebpackPlugin = require('html-webpack-plugin'); //配置 plugins: [ new HtmlWebpackPlugin({ // 打包输出HTML title: 'Hello World app', favicon: '', // 指定页面的图标 inject: '', // 引入模板的注入位置（true/false/body/head） minify: { // 压缩HTML文件 removeComments: true, // 移除HTML中的注释 collapseWhitespace: true, // 删除空白符与换行符 caseSensitive: false, // 是否大小写敏感 minifyCSS: true // 压缩内联css }, template: 'index.html', // 模板来源html文件 filename: 'index.html' // 生成的模板文件名 }) ] 4.2.2.图片压缩插件(imagemin-webpack-plugin) 作用：批量压缩图片。 安装： npm install --save-dev imagemin-webpack-plugin 配置： //引入插件 var ImageminPlugin = require('imagemin-webpack-plugin').default; //配置 plugins: [ new ImageminPlugin({ disable: process.env.NODE_ENV !== 'production', // 开发时不启用 pngquant: {//图片质量 quality: '95-100' } }) ] 4.2.3.清空文件夹插件(clean-webpack-plugin) 作用：打包前先清空output文件夹。 安装： npm install --save-dev clean-webpack-plugin 配置： //引入 const CleanWebpackPlugin = require('clean-webpack-plugin'); //清空dist文件夹 plugins: [ new CleanWebpackPlugin(['public']) ] 4.2.4.删除冗余css插件(purifycss-webpack) 作用：去除冗余的css代码。 安装： npm install --save-dev purifycss-webpack 配置： const purifycssWebpack = require('purifycss-webpack'); const glob = require('glob'); // Make sure this is after ExtractTextPlugin! new purifycssWebpack({ 　　paths: glob.sync(path.resolve('./public/*.html')) }), 4.2.5.加速代码构建(happypack) 作用：通过多进程模型，来加速代码构建。 安装： npm install --save-dev happypack 配置： const os = require('os'); let HappyPack = require('happypack'); let happyThreadPool = HappyPack.ThreadPool({size: os.cpus().length}); exports.plugins = [ new HappyPack({ id: 'jsx', threadPool: happyThreadPool, loaders: [ 'babel-loader' ] }), new HappyPack({ id: 'coffeescripts', threadPool: happyThreadPool, loaders: [ 'coffee-loader' ] }) ]; exports.module.loaders = [ { test: /\\.js$/, loaders: [ 'happypack/loader?id=jsx' ] }, { test: /\\.coffee$/, loaders: [ 'happypack/loader?id=coffeescripts' ] }, ] 4.2.6.提取公共模块(CommonsChunkPlugin) 作用：提取代码中的公共模块，单独生成一个或多个文件，这样避免在多入口重复打包文件。 配置： var webpack = require('webpack'); module.exports = { entry:['index1.js','index2.js'], plugins: [ new CommonsChunkPlugin({ name:\"entry\", filename:\"common.js\", //忽略则以name为输出文件的名字，否则以此为输出文件名字 minChunks:2, // 最小引用2次 }) ] }; // 把 index1.js，index2.js公用的js抽取出来，打包成单独文件common.js。 4.2.7.js压缩(UglifyJsPlugin) 作用：压缩js文件。 配置： var webpack = require('webpack'); module.exports = { entry:['index.js'], plugins: [ new webpack.optimize.UglifyJsPlugin({ compress: { warnings: VERBOSE, }, }) ] }; 4.2.8.开启服务插件(webpack-dev-server) 作用：可以完成自动刷新、热替换等功能的服务端。 安装： npm install --save-dev webpack-dev-server 配置： // package.json { // ... \"scripts\": { \"dev\": \"webpack-dev-server --open --hot\", \"build\": \"set NODE_ENV=production && webpack\" }, // ... } // webpack.config.js const path = require(path); module.exports = { // ... plugins: [ new webpack.HotModuleReplacementPlugin() // 热模块替换：只替换更新部分,不会页面重载. ], devServer: { contentBase: path.join(__dirname, 'public'), port: 8000, // inline: false, hot: true, } } 参考：webpack常用插件 专注之后，始能忘忧...®Python, Ruby, PHP & web前端Copyright © Mr. Yao all right reserved, powered by skyFimodified at 2020-04-15 22:04:29 "},"其他/4_个人网站之GitBook的简单使用.html":{"url":"其他/4_个人网站之GitBook的简单使用.html","title":"3.4.GitBook的简单使用","keywords":"","body":" 相比于博客网站（如：CSDN、简书、Hexo搭建的个人博客等），个人感觉GitBook更能做一些系列型的技术存档与学习， 前者更适合做一些笔记的整理和技术分享，而GitBook的作用相当于将这些笔记做了一些归纳，类似电子书的方式。 对于查询资料和文档整理会更好些，当然，工具的使用因人而异。 1.环境安装 使用之前，先确保安装了 Git 和 Node.js。 1.1.安装 Git 工具 传送门：Git 下载 检查环境变量，将 Git 加入系统环境变量，做一些简单的配置： # 设定user和email git config --global user.name \"username\" git config --global user.email \"email@example.com\" # 创建SSH Key，使用ssh进行上传提交更新时需要公钥，生成获取pubkey ssh-keygen -t rsa -b 4096 -C \"email@example.com\" 1.2.安装 Node.js 环境 传送门：Node.js 下载 选好版本下载、安装完成后，同样将程序加入环境变量。 检查安装结果： # 检查 node 和 npm 版本 node -v npm -v 1.3.安装 GitBook 官网：GitBook 安装 GitBook 插件： npm install gitbook-cli -g 检查版本： $ gitbook -V CLI version: 2.3.2 GitBook version: 3.2.3 2.简单使用 2.1.初始化图书目录 在图书目录，打开 gitbash 或者 DOS 窗口，输入： $ gitbook init warn: no summary file in this book info: create README.md info: create SUMMARY.md info: initialization is finished 此时，目录下会生成 README.md 和 SUMMARY.md 这两个文件。 前者是 图书说明文档，后者是目录章节配置文档。 # Introduction # Summary * [Introduction](README.md) 2.2.一些简单操作 将要写的文章系列以 mrakdown 的形式生成，放到图书根目录下。 （1）、将 .md 文件转成页面文件 .html，运行 命令: gitbook build 此时，根目录中会生成 _book 目录，这是网站的静态资源目录。 （2）、本地运行，在网页显示GitBook页面内容，运行 命令： gitbook serve --port=xxxx 此时，浏览器输入网址： http://localhost:xxxx，即可打开本地部署的网站。 （3）、命令帮助 命令行输入以下命令，会显示 gitbook 的 帮助信息： gitbook help （4）、安装插件 命令行输入： npm install （5）、更新和卸载 命令行输入： # 更新 gitbook update # 卸载 gitbook uninstall 2.3.配置 book.json 文件 根目录下，新建文件 book.json，内容如下： { \"title\" : \"标题\", \"author\": \"作者\", \"description\": \"描述\", \"extension\": null, \"generator\": \"site\", \"language\" : \"zh-hans\", \"links\": { \"sharing\": { \"all\": null, \"facebook\": null, \"google\": null, \"twitter\": null, \"weibo\": null }, \"sidebar\": { \"个人主页\": \"网址\" } }, \"variables\": {} } 3.GitBook 部分常用插件 book.json 插件配置： 插件放置在 plugins 数组中。 插件配置在 pluginsConfig 字典中。 3.1.expandable-chapters 章节导航扩展 { \"plugins\": [ \"expandable-chapters\" ] } 3.2.copy-code-button 代码复制按钮 { \"plugins\": [\"copy-code-button\"] } 3.3. search-plus 页面搜索 { \"plugins\": [\"search-plus\"] } 3.4.右上角添加 github 图标 { \"plugins\": [ \"github\" ], \"pluginsConfig\": { \"github\": { \"url\": \"https://github.com/{github-id}\" } } } 3.5.splitter 侧边栏宽度可调节 { \"plugins\": [\"splitter\"] } 3.6.sharing-plus 分享 { \"plugins\": [\"-sharing\", \"sharing-plus\"], \"pluginsConfig\": { \"sharing\": { \"douban\": false, \"facebook\": false, \"google\": true, \"pocket\": false, \"qq\": false, \"qzone\": true, \"twitter\": false, \"weibo\": true, \"all\": [ \"douban\", \"facebook\", \"google\", \"instapaper\", \"linkedin\",\"twitter\", \"weibo\", \"messenger\",\"qq\", \"qzone\",\"viber\",\"whatsapp\" ] } } } 3.7.page-copyright 页面页脚版权 { \"plugins\" : [\"page-copyright\"], \"pluginsConfig\" : { \"page-copyright\": { \"description\": \"modified at\", \"signature\": \"你的签名\", \"wisdom\": \"Designer info\", \"format\": \"YYYY-MM-dd hh:mm:ss\", \"copyright\": \"Copyright &#169; 你的名字\", \"timeColor\": \"#666\", \"copyrightColor\": \"#666\", \"utcOffset\": \"8\", \"style\": \"normal\", \"noPowered\": false, } } } 3.8.anchor-navigation-ex 悬浮目录与置顶 { \"plugins\" : [ \"anchor-navigation-ex\" ], \"pluginsConfig\": { \"anchor-navigation-ex\": { \"showLevel\": true, \"associatedWithSummary\": true, \"printLog\": false, \"multipleH1\": true, \"mode\": \"float\", \"showGoTop\":true, \"float\": { \"floatIcon\": \"fa fa-navicon\", \"showLevelIcon\": false, \"level1Icon\": \"fa fa-hand-o-right\", \"level2Icon\": \"fa fa-hand-o-right\", \"level3Icon\": \"fa fa-hand-o-right\" }, \"pageTop\": { \"showLevelIcon\": false, \"level1Icon\": \"fa fa-hand-o-right\", \"level2Icon\": \"fa fa-hand-o-right\", \"level3Icon\": \"fa fa-hand-o-right\" } }, } } 3.9.donate 打赏 { \"plugins\" : [ \"donate\" ], \"donate\": { \"wechat\": \"微信图片\", \"alipay\": \"支付宝图片\", \"title\": \"\", \"button\": \"赏\", \"alipayText\": \"支付宝打赏\", \"wechatText\": \"微信打赏\" }, } 3.10.mygitalk 评论插件 { \"plugins\" : [ \"mygitalk\" ], \"mygitalk\": { \"clientID\": \"gitalk id\", \"clientSecret\": \"密钥\", \"repo\": \"\", \"owner\": \"GitHub id\", \"admin\": [\"username\"], \"distractionFreeMode\": false }, } 4.安装 gitbook 插件 命令行输入： gitbook install 可能会比较慢，等待一会儿，安装完成后再重新构建页面和启动服务。 参考： GitBook 插件整理 专注之后，始能忘忧...®Python, Ruby, PHP & web前端Copyright © Mr. Yao all right reserved, powered by skyFimodified at 2020-04-15 22:06:39 "}}